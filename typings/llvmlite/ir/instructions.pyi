"""
This type stub file was generated by pyright.
"""

from llvmlite.ir.values import AttributeSet, NamedValue
from llvmlite.ir._utils import _HasMetadata

"""
Implementation of LLVM IR instructions.
"""
class Instruction(NamedValue, _HasMetadata):
    def __init__(self, parent, typ, opname, operands, name=..., flags=...) -> None:
        ...
    
    @property
    def function(self):
        ...
    
    @property
    def module(self):
        ...
    
    def descr(self, buf): # -> None:
        ...
    
    def replace_usage(self, old, new): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class CallInstrAttributes(AttributeSet):
    _known = ...


TailMarkerOptions = ...
class FastMathFlags(AttributeSet):
    _known = ...


class CallInstr(Instruction):
    def __init__(self, parent, func, args, name=..., cconv=..., tail=..., fastmath=..., attrs=..., arg_attrs=...) -> None:
        ...
    
    @property
    def callee(self):
        ...
    
    @callee.setter
    def callee(self, newcallee): # -> None:
        ...
    
    @property
    def args(self): # -> tuple[Any, ...]:
        ...
    
    def replace_callee(self, newfunc): # -> None:
        ...
    
    @property
    def called_function(self):
        """The callee function"""
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class InvokeInstr(CallInstr):
    def __init__(self, parent, func, args, normal_to, unwind_to, name=..., cconv=..., fastmath=..., attrs=..., arg_attrs=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Terminator(Instruction):
    def __init__(self, parent, opname, operands) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class PredictableInstr(Instruction):
    def set_weights(self, weights): # -> None:
        ...
    


class Ret(Terminator):
    def __init__(self, parent, opname, return_value=...) -> None:
        ...
    
    @property
    def return_value(self): # -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Branch(Terminator):
    ...


class ConditionalBranch(PredictableInstr, Terminator):
    ...


class IndirectBranch(PredictableInstr, Terminator):
    def __init__(self, parent, opname, addr) -> None:
        ...
    
    @property
    def address(self):
        ...
    
    def add_destination(self, block): # -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class SwitchInstr(PredictableInstr, Terminator):
    def __init__(self, parent, opname, val, default) -> None:
        ...
    
    @property
    def value(self):
        ...
    
    def add_case(self, val, block): # -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Resume(Terminator):
    ...


class SelectInstr(Instruction):
    def __init__(self, parent, cond, lhs, rhs, name=..., flags=...) -> None:
        ...
    
    @property
    def cond(self):
        ...
    
    @property
    def lhs(self):
        ...
    
    @property
    def rhs(self):
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class CompareInstr(Instruction):
    OPNAME = ...
    VALID_OP = ...
    def __init__(self, parent, op, lhs, rhs, name=..., flags=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class ICMPInstr(CompareInstr):
    OPNAME = ...
    VALID_OP = ...
    VALID_FLAG = ...


class FCMPInstr(CompareInstr):
    OPNAME = ...
    VALID_OP = ...
    VALID_FLAG = ...


class CastInstr(Instruction):
    def __init__(self, parent, op, val, typ, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class LoadInstr(Instruction):
    def __init__(self, parent, ptr, name=..., typ=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class StoreInstr(Instruction):
    def __init__(self, parent, val, ptr) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class LoadAtomicInstr(Instruction):
    def __init__(self, parent, ptr, ordering, align, name=..., typ=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class StoreAtomicInstr(Instruction):
    def __init__(self, parent, val, ptr, ordering, align) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class AllocaInstr(Instruction):
    def __init__(self, parent, typ, count, name) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class GEPInstr(Instruction):
    def __init__(self, parent, ptr, indices, inbounds, name, source_etype=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class PhiInstr(Instruction):
    def __init__(self, parent, typ, name, flags=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    
    def add_incoming(self, value, block): # -> None:
        ...
    
    def replace_usage(self, old, new): # -> None:
        ...
    


class ExtractElement(Instruction):
    def __init__(self, parent, vector, index, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class InsertElement(Instruction):
    def __init__(self, parent, vector, value, index, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class ShuffleVector(Instruction):
    def __init__(self, parent, vector1, vector2, mask, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class ExtractValue(Instruction):
    def __init__(self, parent, agg, indices, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class InsertValue(Instruction):
    def __init__(self, parent, agg, elem, indices, name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Unreachable(Instruction):
    def __init__(self, parent) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class InlineAsm:
    def __init__(self, ftype, asm, constraint, side_effect=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    
    def get_reference(self): # -> LiteralString:
        ...
    
    def __str__(self) -> str:
        ...
    


class AtomicRMW(Instruction):
    def __init__(self, parent, op, ptr, val, ordering, name) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class CmpXchg(Instruction):
    """This instruction has changed since llvm3.5.  It is not compatible with
    older llvm versions.
    """
    def __init__(self, parent, ptr, cmp, val, ordering, failordering, name) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class _LandingPadClause:
    def __init__(self, value) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class CatchClause(_LandingPadClause):
    kind = ...


class FilterClause(_LandingPadClause):
    kind = ...
    def __init__(self, value) -> None:
        ...
    


class LandingPadInstr(Instruction):
    def __init__(self, parent, typ, name=..., cleanup=...) -> None:
        ...
    
    def add_clause(self, clause): # -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Fence(Instruction):
    """
    The `fence` instruction.

    As of LLVM 5.0.1:

    fence [syncscope("<target-scope>")] <ordering>  ; yields void
    """
    VALID_FENCE_ORDERINGS = ...
    def __init__(self, parent, ordering, targetscope=..., name=...) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


class Comment(Instruction):
    """
    A line comment.
    """
    def __init__(self, parent, text) -> None:
        ...
    
    def descr(self, buf): # -> None:
        ...
    


