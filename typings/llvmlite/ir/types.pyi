"""
This type stub file was generated by pyright.
"""

from llvmlite.ir._utils import _StrCaching

"""
Classes that are LLVM types
"""
class Type(_StrCaching):
    """
    The base class for all LLVM types.
    """
    is_pointer = ...
    null = ...
    def __repr__(self): # -> str:
        ...
    
    def as_pointer(self, addrspace=...): # -> PointerType:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def get_abi_size(self, target_data, context=...):
        """
        Get the ABI size of this type according to data layout *target_data*.
        """
        ...
    
    def get_element_offset(self, target_data, ndx, context=...):
        ...
    
    def get_abi_alignment(self, target_data, context=...):
        """
        Get the minimum ABI alignment of this type according to data layout
        *target_data*.
        """
        ...
    
    def format_constant(self, value): # -> str:
        """
        Format constant *value* of this type.  This method may be overriden
        by subclasses.
        """
        ...
    
    def wrap_constant_value(self, value):
        """
        Wrap constant *value* if necessary.  This method may be overriden
        by subclasses (especially aggregate types).
        """
        ...
    
    def __call__(self, value): # -> Constant:
        """
        Create a LLVM constant of this type with the given Python value.
        """
        ...
    


class MetaDataType(Type):
    def as_pointer(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class LabelType(Type):
    """
    The label type is the type of e.g. basic blocks.
    """
    ...


class PointerType(Type):
    """
    The type of all pointer values.
    By default (without specialisation) represents an opaque pointer.
    """
    is_opaque = ...
    is_pointer = ...
    null = ...
    def __new__(cls, pointee=..., addrspace=...): # -> Self | PointerType:
        ...
    
    def __init__(self, addrspace=...) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> _TypedPointerType | Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class _TypedPointerType(PointerType):
    """
    The type of typed pointer values. To be removed eventually.
    """
    def __init__(self, pointee, addrspace=...) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def gep(self, i):
        """
        Resolve the type of the i-th element (for getelementptr lookups).
        """
        ...
    
    @property
    def intrinsic_name(self): # -> str:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class VoidType(Type):
    """
    The type for empty values (e.g. a function returning no value).
    """
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class FunctionType(Type):
    """
    The type for functions.
    """
    def __init__(self, return_type, args, var_arg=...) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class IntType(Type):
    """
    The type for integers.
    """
    null = ...
    _instance_cache = ...
    width: int
    def __new__(cls, bits): # -> Self:
        ...
    
    def __getnewargs__(self): # -> tuple[int]:
        ...
    
    def __copy__(self): # -> Self:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def format_constant(self, val): # -> str:
        ...
    
    def wrap_constant_value(self, val): # -> Literal[0]:
        ...
    
    @property
    def intrinsic_name(self): # -> str:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> IntType:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class _BaseFloatType(Type):
    def __new__(cls): # -> Self:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class HalfType(_BaseFloatType):
    """
    The type for single-precision floats.
    """
    null = ...
    intrinsic_name = ...
    def __str__(self) -> str:
        ...
    
    def format_constant(self, value): # -> str:
        ...
    


class FloatType(_BaseFloatType):
    """
    The type for single-precision floats.
    """
    null = ...
    intrinsic_name = ...
    def __str__(self) -> str:
        ...
    
    def format_constant(self, value): # -> str:
        ...
    


class DoubleType(_BaseFloatType):
    """
    The type for double-precision floats.
    """
    null = ...
    intrinsic_name = ...
    def __str__(self) -> str:
        ...
    
    def format_constant(self, value): # -> str:
        ...
    


class _Repeat:
    def __init__(self, value, size) -> None:
        ...
    
    def __len__(self): # -> Any:
        ...
    
    def __getitem__(self, item): # -> Any:
        ...
    


class VectorType(Type):
    """
    The type for vectors of primitive data items (e.g. "<f32 x 4>").
    """
    def __init__(self, element, count) -> None:
        ...
    
    @property
    def elements(self): # -> _Repeat:
        ...
    
    def __len__(self): # -> Any:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __copy__(self): # -> Self:
        ...
    
    def format_constant(self, value): # -> str:
        ...
    
    def wrap_constant_value(self, values): # -> tuple[Constant, ...] | list[Constant | Value]:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class Aggregate(Type):
    """
    Base class for aggregate types.
    See http://llvm.org/docs/LangRef.html#t-aggregate
    """
    def wrap_constant_value(self, values): # -> list[Constant | Value]:
        ...
    


class ArrayType(Aggregate):
    """
    The type for fixed-size homogenous arrays (e.g. "[f32 x 3]").
    """
    def __init__(self, element, count) -> None:
        ...
    
    @property
    def elements(self): # -> _Repeat:
        ...
    
    def __len__(self): # -> Any:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def gep(self, i): # -> Any:
        """
        Resolve the type of the i-th element (for getelementptr lookups).
        """
        ...
    
    def format_constant(self, value): # -> str:
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class BaseStructType(Aggregate):
    """
    The base type for heterogenous struct types.
    """
    _packed = ...
    @property
    def packed(self): # -> bool:
        """
        A boolean attribute that indicates whether the structure uses
        packed layout.
        """
        ...
    
    @packed.setter
    def packed(self, val): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self):
        ...
    
    @property
    def is_opaque(self): # -> bool:
        ...
    
    def structure_repr(self): # -> str:
        """
        Return the LLVM IR for the structure representation
        """
        ...
    
    def format_constant(self, value): # -> str:
        ...
    
    def gep(self, i):
        """
        Resolve the type of the i-th element (for getelementptr lookups).

        *i* needs to be a LLVM constant, so that the type can be determined
        at compile-time.
        """
        ...
    
    @classmethod
    def from_llvm(cls, typeref, ir_ctx): # -> Self:
        """
        Create from a llvmlite.binding.TypeRef
        """
        ...
    


class LiteralStructType(BaseStructType):
    """
    The type of "literal" structs, i.e. structs with a literally-defined
    type (by contrast with IdentifiedStructType).
    """
    null = ...
    def __init__(self, elems, packed=...) -> None:
        """
        *elems* is a sequence of types to be used as members.
        *packed* controls the use of packed layout.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class IdentifiedStructType(BaseStructType):
    """
    A type which is a named alias for another struct type, akin to a typedef.
    While literal struct types can be structurally equal (see
    LiteralStructType), identified struct types are compared by name.

    Do not use this directly.
    """
    null = ...
    def __init__(self, context, name, packed=...) -> None:
        """
        *context* is a llvmlite.ir.Context.
        *name* is the identifier for the new struct type.
        *packed* controls the use of packed layout.
        """
        ...
    
    def get_declaration(self): # -> str:
        """
        Returns the string for the declaration of the type
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def set_body(self, *elems): # -> None:
        ...
    


