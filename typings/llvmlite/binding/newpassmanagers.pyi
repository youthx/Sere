"""
This type stub file was generated by pyright.
"""

from enum import IntFlag
from llvmlite.binding import ffi

def create_new_module_pass_manager(): ...
def create_new_function_pass_manager(): ...
def create_pass_builder(tm, pto): ...
def create_pipeline_tuning_options(speed_level=..., size_level=...): ...

class RefPruneSubpasses(IntFlag):
    PER_BB = ...
    DIAMOND = ...
    FANOUT = ...
    FANOUT_RAISE = ...
    ALL = ...

class ModulePassManager(ffi.ObjectRef):
    def __init__(self, ptr=...) -> None: ...
    def run(self, module, pb): ...
    def add_verifier(self): ...
    def add_aa_eval_pass(self): ...
    def add_simplify_cfg_pass(self): ...
    def add_loop_unroll_pass(self): ...
    def add_loop_rotate_pass(self): ...
    def add_instruction_combine_pass(self): ...
    def add_jump_threading_pass(self, threshold=...): ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit=...):  # -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """
        ...

class FunctionPassManager(ffi.ObjectRef):
    def __init__(self, ptr=...) -> None: ...
    def run(self, fun, pb): ...
    def add_aa_eval_pass(self): ...
    def add_simplify_cfg_pass(self): ...
    def add_loop_unroll_pass(self): ...
    def add_loop_rotate_pass(self): ...
    def add_instruction_combine_pass(self): ...
    def add_jump_threading_pass(self, threshold=...): ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit=...):  # -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """
        ...

class PipelineTuningOptions(ffi.ObjectRef):
    def __init__(self, speed_level=..., size_level=...) -> None: ...
    @property
    def speed_level(self): ...
    @speed_level.setter
    def speed_level(self, value): ...
    @property
    def size_level(self): ...
    @size_level.setter
    def size_level(self, value): ...
    @property
    def loop_interleaving(self): ...
    @loop_interleaving.setter
    def loop_interleaving(self, value): ...
    @property
    def loop_vectorization(self): ...
    @loop_vectorization.setter
    def loop_vectorization(self, value): ...
    @property
    def slp_vectorization(self): ...
    @slp_vectorization.setter
    def slp_vectorization(self, value): ...
    @property
    def loop_unrolling(self): ...
    @loop_unrolling.setter
    def loop_unrolling(self, value): ...

class PassBuilder(ffi.ObjectRef):
    def __init__(self, tm, pto) -> None: ...
    def getModulePassManager(self): ...
    def getFunctionPassManager(self): ...
